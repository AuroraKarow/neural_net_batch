/* This is a C/C++ precompiling header
 * DOC C++ 17
 * DATE 2021-02-10 9:30 PM
 * COMP MSVC Windows 10
 * AUTHOR Liao
 * ~ God bless no bug ~
 */
#define MATRIX_BEGIN namespace Matrix {
#define MATRIX_END }

// MATRIX NAMESPACE_BEGIN
MATRIX_BEGIN

// Pointer matrix
using MATRIX = std::unique_ptr<double[]>;
// From array to position
std::pair<uint64_t, uint64_t> get_elem_pos(uint64_t _Idx, uint64_t ln_cnt, uint64_t col_cnt)
{
    if(ln_cnt && col_cnt) return std::make_pair(_Idx/ln_cnt, _Idx%col_cnt);
    else return std::make_pair(0, 0);
}
/* Validate the position of pointer matrix.
 * - Parameter
 * ln   [Input] Line directed position      -
 * col  [Input] Column directed position    -
 * - Return
 * [true]   valid
 * [false]  Invalid
 */
bool is_pos_valid(uint64_t ln, uint64_t col, uint64_t ln_cnt, uint64_t col_cnt)
{
    if (ln < ln_cnt && col < col_cnt) return true;
    else return false;
}
/* Get matrix element's position.
 * - Parameter
 * ln       [Input] Line directed position      -
 * col      [Input] Column directed position    -
 * ln_cnt   [Input] Matrix's line count         -
 * col_cnt  [Input] Matrix's column count       -
 * - Return
 * Position of the pointer
 */
uint64_t get_elem_pos(uint64_t ln, uint64_t col, uint64_t ln_cnt, uint64_t col_cnt)
{
    if (is_pos_valid(ln, col, ln_cnt, col_cnt)) return ln * col_cnt + col;
    else return 0;
}
MATRIX init_matrix(uint64_t elem_cnt)
{
    auto vec = std::make_unique<double[]>(elem_cnt);
    for(auto i=0; i<elem_cnt; i++) vec[i] = 0;
    return vec;
}
/* Initialize a pointer matrix.
 * - Parameter
 * ln_cnt   [Input] Matrix's line count     -
 * col_cnt  [Input] Matrix's column count   -
 * - Return
 * Initialized pointer matrix
 */
MATRIX init_matrix(uint64_t ln_cnt, uint64_t col_cnt)
{
    return init_matrix(ln_cnt * col_cnt);
}
/* Initialize a unit pointer matrix.
 * - Parameter
 * dim  [Input] Matrix's dimension  -
 * - Return
 * Initialized pointer unit matrix
 */
MATRIX init_E_vec(int dim)
{
    auto e = init_matrix(dim, dim);
    for (int i = 0; i < dim; i++)
        for (int j = 0; j < dim; j++)
            if (i == j) e[get_elem_pos(i, j, dim, dim)] = 1.0;
    return e;
}
// Refresh matrix
void refresh(MATRIX &vec_src, uint64_t len)
{
    for(auto i=0; i<len; i++) vec_src[i] = 0;
}
// Delete a pointer matrix.
void delete_matrix() {}
// void delete_matrix() {}
/* - Overload
 * Delete a pointer matrix.
 * - Parameter
 * matrix   [Input] Pointer matrix  -
 * - Return -
 * void
 */
void delete_matrix(MATRIX &matrix)
{
    matrix.reset();
    matrix.release();
}
/* - Overload
 * Delete a pointer matrix.
 * - Parameter
 * h_vec    [Input] First pointer matrix    -
 * vec_seq  [Input] Left pointers           -
 * - Return
 * void
 */
template <typename p_vec, typename... p_vecs> void delete_matrix(p_vec& h_vec, p_vecs& ... vec_seq)
{
    delete_matrix(h_vec);
    delete_matrix(vec_seq...);
}
/* Get matrix element's value.
 * - Parameter
 * vec      [Input] Pointer matrix              -
 * ln       [Input] Line directed position      -
 * col      [Input] Column directed position    -
 * ln_cnt   [Input] Matrix's line count         -
 * col_cnt  [Input] Matrix's column count       -
 * - Return
 * Counterpart value of selected line and column position
 */
double get_matrix_value(MATRIX &vec, uint64_t ln, uint64_t col, uint64_t ln_cnt, uint64_t col_cnt)
{
    if (is_pos_valid(ln, col, ln_cnt, col_cnt)) return vec[ln * col_cnt + col];
    else return 0;
}
/* Set matrix element's value.
 * - Parameter
 * vec      [Input] Pointer matrix              -
 * ln       [Input] Line directed position      -
 * col      [Input] Column directed position    -
 * ln_cnt   [Input] Matrix's line count         -
 * col_cnt  [Input] Matrix's column count       -
 * - Return
 * [true]   Assign successfully
 * [false]  Assign faliled
 */
bool set_matrix_value(MATRIX &vec, double value, uint64_t ln, uint64_t col, uint64_t ln_cnt, uint64_t col_cnt)
{
    if (is_pos_valid(ln, col, ln_cnt, col_cnt))
    {
        vec[ln * col_cnt + col] = value;
        return true;
    }
    else return false;
}
/* Print the pointer matrix on console.
 * - Parameter
 * vec      [Input] Pointer matrix          -
 * ln_cnt   [Input] Matrix's line count     -
 * col_cnt  [Input] Matrix's column count   -
 * - Return
 * void
 */
void show_matrix(MATRIX &vec, uint64_t ln_cnt, uint64_t col_cnt)
{
    auto elem_amt = ln_cnt * col_cnt;
    for (auto i = 0; i < elem_amt; i++)
    {
        std::cout << vec[i];
        if ((i + 1) % col_cnt) std::cout << '\t';
        else std::cout << std::endl;
    }
}
/* - Overload
 * Print the pointer matrix (2D) on console.
 * - Parameter
 * vec      [Input] Pointer matrix (2D)     -
 * ln_cnt   [Input] Matrix's line count     -
 * col_cnt  [Input] Matrix's column count   -
 * - Return
 * void
 */
void show_matrix(std::unique_ptr<std::unique_ptr<double[]>[]> &matrix, int line, int column)
{
    for (int i = 0; i < line; i++)
    {
        for (int j = 0; j < column; j++)
            std::cout << matrix[i][j] << '\t';
        std::cout << std::endl;
    }
}
/* Matrix determinant calculation.
 * - Parameter
 * vec  [Input] Pointer matrix          -
 * dim  [Input] Dimension of the matrix -
 * - Return
 * Determinant value
 */
double get_matrix_det(MATRIX &vec, int dim)
{
    if (dim == 1)
        return vec[0];
    // create nD algebraic cofactor
    auto ac = init_matrix((dim - 1), (dim - 1));
    // move sign
    int mov = 0;
    // det initialization
    double sum = 0.0;
    // assign the matrix line amount to ac[n-1]
    for (int arow = 0; arow < dim; arow++)
    {
        // assign the matrix each column ac to ac array
        for (int brow = 0; brow < dim - 1; brow++)
        {
            /* < arrow   assign to the same line
             * = arrow   dismiss
             * > arrow  ++
             */
            mov = arow > brow ? 0 : 1;
            // assign the matrix[][1] to matrix[][dim-1]
            for (int j = 0; j < dim - 1; j++)
                ac[brow * (dim - 1) + j] = vec[(brow + mov) * dim + j + 1];
        } // judge the line number whether is 0, ac would be 1 when the line amount is a even.
        int flag = (arow % 2 == 0 ? 1 : -1);
        // Recursive process
        sum += flag * vec[arow * dim] * get_matrix_det(ac, dim - 1);
    }
    delete_matrix(ac);
    return sum;
}
/* Get average value of an array.
 * - Parameter
 * array    [Input] Array pointer   -
 * length   [Input] Array's length  -
 * - Return
 * Average value
 */
double get_avg_value(MATRIX &array, int length)
{
    auto sum = 0.0;
    for (auto i = 0; i < length; i++) sum += array[i];
    return sum / length;
}
/* Get Max value of an array
 * - Parameter
 * array    [Input]     Array pointer                   -
 * length   [Input]     Array's length                  -
 * location [Output]    Max value's location in array   -
 * - Return
 * Max value
 */
double get_max_value(MATRIX &array, int length, int &location)
{
    double max = array[0];
    location = 0;
    for (int i = 1; i < length; i++)
    {
        if (array[i] > max) max = array[i];
        location = i;
    }
    return max;
}
/* Get Min value of an array.
 * - Parameter
 * array    [Input]     Array pointer                   -
 * length   [Input]     Array's length                  -
 * location [Output]    Min value's location in array   -
 * - Return
 * Min value
 */
double get_min_value(MATRIX &array, int length, int &location)
{
    double min = array[0];
    location = 0;
    for (int i = 1; i < length; i++)
    {
        if (array[i] < min) min = array[i];
        location = i;
    }
    return min;
}
MATRIX copy_matrix(MATRIX &vec, uint64_t elem_cnt)
{
    auto cpy_elem = init_matrix(elem_cnt);
    for(auto i=0; i<elem_cnt; i++) cpy_elem[i] = vec[i];
    return cpy_elem;
}
/* Copy pointer matrix.
 * - Parameter
 * vec      [Input] Pointer matrix          -
 * ln_cnt   [Input] Matrix's line count     -
 * col_cnt  [Input] Matrix's column count   -
 * - Return
 * Matrix replication pointer
 */
MATRIX copy_matrix(MATRIX &vec, uint64_t ln_cnt, uint64_t col_cnt)
{
    return copy_matrix(vec, ln_cnt * col_cnt);
}
/* Extract a matrix from a matrix string.
 * - Parameter
 * mat_str  [Input] String pointer matrix   -
 * line     [Input] Matrix's line count     -
 * column   [Input] Matrix's column count   -
 * - Return
 * Matrix pointer
 */
MATRIX get_matrix(std::string mat_str, int &line, int &column)
{
    column = 0;
    line = 0;
    int cnt = 0;
    // get column amount
    while (mat_str[cnt] != '\n' && mat_str[cnt] != '\0')
    {
        if (mat_str[cnt] == '.' || mat_str[cnt] == '-' || mat_str[cnt] == '+' ||
            (mat_str[cnt] >= '0' && mat_str[cnt] <= '9') || mat_str[cnt] == '/')
            if (mat_str[cnt - 1] == ' ' || mat_str[cnt - 1] == '\t' || cnt - 1 < 0)
                column++;
        cnt++;
    }
    for (int i = 0; i < mat_str.length(); i++)
    {
        if (mat_str[i] == '\n') line++;
    }
    return extract_number(mat_str);
}
/* Matrix transposition operation.
 * - Parameter
 * vec_src      [Input] Pointer matrix              -
 * ln_cnt       [Input] Matrix's line count         -
 * col_cnt      [Input] Matrix's column count       -
 * keep_origin  [Input] Keep original matrix flag   true
 * - Return
 * Transposition matrix pointer
 */
MATRIX matrix_transposition(MATRIX &vec_src, uint64_t ln_cnt, uint64_t col_cnt, bool keep_origin = true)
{
    if (keep_origin)
    {
        auto cpy_vec = init_matrix(ln_cnt, col_cnt);
        for (auto i = 0; i < ln_cnt; i++)
            for (auto j = 0; j < col_cnt; j++)
                if (set_matrix_value(cpy_vec, get_matrix_value(vec_src, i, j, ln_cnt, col_cnt), j, i, col_cnt, ln_cnt))
                    continue;
                else
                {
                    delete_matrix(cpy_vec);
                    cpy_vec = nullptr;
                    i = ln_cnt;
                    break;
                }
        return cpy_vec;
    }
    else
    {
        for (auto i = 0; i < ln_cnt; i++)
            for (auto j = 0; j < col_cnt; j++)
                if (i < j) swap_value(vec_src[get_elem_pos(i, j, ln_cnt, col_cnt)], vec_src[get_elem_pos(j, i, ln_cnt, col_cnt)]);
        return copy_matrix(vec_src, ln_cnt * col_cnt);
    }
}
/* Matrix addition, the addition left and right matrix should have same line and column count.
 * - Parameter
 * l_vec    [Input] Addition left matrix    -
 * r_vec    [Input] Addition right matrix   -
 * ln_cnt   [Input] Matrix's line count     -
 * col_cnt  [Input] Matrix's column count   -
 * - Return
 * Result matrix pointer
 */
MATRIX add_matrix(MATRIX &l_vec, MATRIX &r_vec, uint64_t ln_cnt, uint64_t col_cnt)
{
    auto res_vec = init_matrix(ln_cnt, col_cnt);
    auto elem_amt = ln_cnt * col_cnt;
    for (auto i = 0; i < elem_amt; i++) res_vec[i] = l_vec[i] + r_vec[i];
    return res_vec;
}
/* Matrix subtraction, the subtraction left and right matrix should have same line and column count.
 * - Parameter
 * l_vec    [Input] subtraction left matrix     -
 * r_vec    [Input] subtraction right matrix    -
 * ln_cnt   [Input] Matrix's line count         -
 * col_cnt  [Input] Matrix's column count       -
 * - Return
 * Result matrix pointer
 */
MATRIX subtract_matrix(MATRIX &l_vec, MATRIX &r_vec, uint64_t ln_cnt, uint64_t col_cnt)
{
    auto res_vec = init_matrix(ln_cnt, col_cnt);
    auto elem_amt = ln_cnt * col_cnt;
    for (auto i = 0; i < elem_amt; i++) res_vec[i] = l_vec[i] - r_vec[i];
    return res_vec;
}
/* Matrix multiplication, the multiplication left matrix's column count should be equal to right matrix's line count.
 * - Parameter
 * l_vec    [Input] subtraction left matrix     -
 * r_vec    [Input] subtraction right matrix    -
 * l_ln     [Input] Left matrix's line count    -
 * l_col    [Input] Left matrix's column count  -
 * r_ln     [Input] Right matrix's line count   -
 * r_col    [Input] Right matrix's column count -
 * - Return
 * Result matrix pointer
 */
MATRIX multiply_matrix(MATRIX &l_vec, MATRIX &r_vec, int l_ln, int l_col, int r_ln, int r_col)
{
    auto res_vec = init_matrix(l_ln, r_col);
    for (int i = 0; i < l_ln; i++)
        for (int j = 0; j < r_col; j++)
        {
            double sum = 0.0;
            for (int k = 0; k < l_col; k++)
                sum += l_vec[get_elem_pos(i, k, l_ln, l_col)] * r_vec[get_elem_pos(k, j, r_ln, r_col)];
            res_vec[get_elem_pos(i, j, l_ln, r_col)] = sum;
        }
    return res_vec;
}
MATRIX add_value(MATRIX &opt_vec, double add_val, uint64_t elem_cnt)
{
    auto ans_vec = copy_matrix(opt_vec, elem_cnt);
    for(auto i=0; i<elem_cnt; i++) ans_vec[i] += add_val;
    return ans_vec;
}
MATRIX add_value(MATRIX &opt_vec, double add_val, uint64_t ln_cnt, uint64_t col_cnt)
{
    return add_value(opt_vec, add_val, ln_cnt * col_cnt);
}
MATRIX subtract_value(MATRIX &opt_vec, double sub_val, uint64_t elem_cnt)
{
    auto ans_vec = copy_matrix(opt_vec, elem_cnt);
    for(auto i=0; i<elem_cnt; i++) ans_vec[i] -= sub_val;
    return ans_vec;
}
MATRIX subtract_value(MATRIX &opt_vec, double sub_val, uint64_t ln_cnt, uint64_t col_cnt)
{
    return subtract_value(opt_vec, sub_val, ln_cnt * col_cnt);
}
/* LU matrix decomposition.
 * - Parameter
 * vec  [Input] Pointer matrix for coefficiency vector  -
 * dim  [Input] Matrix dimension                        -
 * - Return
 * LU matrix pointer
 */
MATRIX get_LU(MATRIX &vec, int dim)
{
    auto lu = copy_matrix(vec, dim, dim);
    auto e = init_E_vec(dim);
    auto l = copy_matrix(e, dim, dim);
    for (int i = 0; i < dim - 1; i++)
    {
        auto tool = copy_matrix(e, dim, dim);
        for (int j = dim - 1; j > i; j--)
            tool[get_elem_pos(j, i, dim, dim)] = -1.0 * lu[get_elem_pos(j, i, dim, dim)] / lu[get_elem_pos(i, j, dim, dim)];
        for (int j = dim - 1; j > i; j--)
            l[get_elem_pos(i, j, dim, dim)] = -1.0 * tool[get_elem_pos(j, i, dim, dim)];
        for (int j = dim - 1; j > i; j--)
            lu[get_elem_pos(j, i, dim, dim)] = -1.0 * tool[get_elem_pos(j, i, dim, dim)];
        lu = multiply_matrix(tool, lu, dim, dim, dim, dim);
    } // get the inversion matrix
    for (int i = 0; i < dim; i++)
        for (int j = 0; j < dim; j++)
            if (i > j)
                lu[get_elem_pos(j, i, dim, dim)] = l[get_elem_pos(j, i, dim, dim)];
    delete_matrix(l, e);
    return lu;
}
/* Linear equation calculation, the equation should have result. (For LU decomposition)
 * - Parameter
 * coefficient  [Input] Coefficiency pointer matrix     -
 * b            [Input] Equation right pointer matrix   -
 * dim          [Input] Coefficiency's dimension        -
 * - Return
 * Equation result
 */
MATRIX equation_result(MATRIX &coefficient, MATRIX &b, int dim)
{
    auto y = init_matrix(dim);
    auto x = init_matrix(dim);
    auto lu = get_LU(coefficient, dim);
    auto e = init_E_vec(dim);
    auto l = copy_matrix(e, dim, dim);
    auto u = copy_matrix(e, dim, dim);
    for (int i = 0; i < dim; i++)
        for (int j = 0; j < dim; j++) if (i <= j)
            u[get_elem_pos(i, j, dim, dim)] = lu[get_elem_pos(i, j, dim, dim)];
            else l[get_elem_pos(i, j, dim, dim)] = lu[get_elem_pos(i, j, dim, dim)];
    for (int i = 0; i < dim; i++) if (i)
    {
        double temp = 0.0;
        for (int j = 0; j < i; j++) temp += y[j] * l[get_elem_pos(i, j, dim, dim)] * 1.0;
        y[i] = b[i] - temp;
    }
    else y[i] = b[i];
    for (int i = dim; i > 0; i--) if (i - dim)
    {
        double temp = 0.0;
        for (int n = i - 1; n < dim - 1; n++)
            temp += u[get_elem_pos(i - 1, n + 1, dim, dim)] * x[n + 1];
        x[i - 1] = (y[i - 1] - temp) / u[get_elem_pos(i - 1, i - 1, dim, dim)];
    }
    else x[dim - 1] = y[dim - 1] / u[get_elem_pos(dim - 1, dim - 1, dim, dim)];
    delete_matrix(y, e, lu, l, u);
    return x;
}
/* Get matrix's inverse matrix.
 * - Parameter
 * matrix       [Input] Original pointer matrix     -
 * dimension    [Input] Original matrix's dimention -
 * - Return
 * Inverse matrix pointer
 */
MATRIX get_inverse_matrix(MATRIX &matrix, int dimension)
{
    auto e = init_E_vec(dimension);
    auto inverse = copy_matrix(e, dimension, dimension);
    for (int i = 0; i < dimension; i++)
    {
        auto b = init_matrix(dimension);
        for (int j = 0; j < dimension; j++)
            b[j] = e[get_elem_pos(j, i, dimension, dimension)];
        auto x = equation_result(matrix, b, dimension);
        for (int n = 0; n < dimension; n++)
            inverse[get_elem_pos(n, i, dimension, dimension)] = x[n];
        delete_matrix(b, x);
    }
    delete_matrix(e);
    return inverse;
}
/* Get matrix's max eigenvalue.
 * - Parameter
 * matrix       [Input]     Pointer matrix              -
 * dimension    [Input]     Original matrix's dimention -
 * w            [Output]    last normalized eigenvector -
 * error        [Input]     Iteration error             0.00001
 * init_elem    [Input]     Iteration initialized value 1
 * - Return -
 * Inverse matrix pointer
 */
double get_max_eigenvalue(MATRIX &matrix, int dimension, MATRIX &w, double error = 1e-5, double init_elem = 1)
{
    double lambda = 0.0, lambda_temp = 0.0;
    auto x = init_matrix(dimension, dimension);
    int cntr = 0;
    for (int i = 0; i < dimension; i++)
        x[get_elem_pos(i, 0, dimension, dimension)] = init_elem;
    do
    {
        lambda = lambda_temp;
        auto temp = init_matrix(dimension);
        for (int i = 0; i < dimension; i++)
            temp[i] = x[get_elem_pos(i, 0, dimension, dimension)];
        double max = get_max_value(absolute_value(temp, dimension), dimension, cntr);
        for (int i = 0; i < dimension; i++)
            x[get_elem_pos(i, 0, dimension, dimension)] /= max;
        for (int i = 0; i < dimension; i++)
            w[i] = x[get_elem_pos(i, 0, dimension, dimension)];
        double sum = 0.0;
        for (int i = 0; i < dimension; i++) sum += w[i];
        for (int i = 0; i < dimension; i++) w[i] /= sum;
        x = multiply_matrix(matrix, x, dimension, dimension, dimension, 1);
        for (int i = 0; i < dimension; i++)
            temp[i] = x[get_elem_pos(i, 0, dimension, dimension)];
        lambda_temp = get_max_value(temp, dimension, cntr);
        delete_matrix(temp);
    } while (absolute_value(lambda_temp - lambda) > error);
    delete_matrix(x, dimension);
    return lambda;
}
/* Linear equation calculation, the equation should have result. (For Jacobi Iteration)
 * - Parameter
 * coefficient  [Input] Coefficiency pointer matrix     -
 * b            [Input] Equation right pointer matrix   -
 * dimension    [Input] Coefficiency's dimension        -
 * error        [Input] Iteration error                 0.00001
 * init_elem    [Input] Iteration initialized value     1
 * - Return
 * Equation result
 */
double *jacobi_iterate(double *coefficient, double *b, int dimension, double error = 1e-5, double init_elem = 1)
{
    double *x = new double[dimension];
    double *temp = new double[dimension];
    for (int i = 0; i < dimension; i++) temp[i] = init_elem;
    bool flag = false;
    do
    {
        flag = false;
        for (int i = 0; i < dimension; i++) x[i] = temp[i];
        for (int i = 0; i < dimension; i++)
        {
            double sum = 0.0;
            for (int j = 0; j < dimension; j++) if (i != j)
                sum += coefficient[get_elem_pos(i, j, dimension, dimension)] * x[j];
            temp[i] = (b[i] - sum) / coefficient[get_elem_pos(i, i, dimension, dimension)];
        }
        for (int i = 0; i < dimension; i++) if (absolute_value(x[i] - temp[i]) >= error)
        {
            flag = true;
            break;
        }
    } while (flag);
    delete_matrix(temp);
    return x;
}
/* Rotate π/2 radian for all element of matrix.
 * - Parameter
 * matrix_value [Input] Pointer matrix          -
 * ln           [Input] Matrix's line count     -
 * col          [Input] Matrix's column count   -
 * - Return
 * Matrix pointer after rotate π/2 radian
 */
MATRIX rotate_rect_matrix(MATRIX &matrix_value, int ln, int col)
{
    auto rot_rec_mat = init_matrix(ln, col);
    for (auto i = 0; i < col; i++)
        for (auto j = 0; j < ln; j++)
            rot_rec_mat[get_elem_pos(i, j, ln, col)] = matrix_value[get_elem_pos(j, col - i - 1, ln, col)];
    return rot_rec_mat;
}
// matrix package
class matrix
{
protected:
    // Pointer matrix
    MATRIX matrix_value;
    // Column count
    int column = 0;
    // Line count
    int line = 0;
    /* Initialize the matrix pointer
     * - Parameter
     * line [Input] Matrix line count   -
     * col  [Input] Matrix column count -
     * - Return
     * void
     */
    // element count
    uint64_t elem_cnt = 0;
    void elem_st(uint64_t ln, uint64_t col)
    {
        column = col;
        line = ln;
        elem_cnt = column * line;
    }
    void mat_ptr_init(int ln, int col)
    {
        elem_st(ln, col);
        matrix_value = init_matrix(ln, col);
    }
public:
    /* White matrix initialization construction function.
     * - Parameter
     * line     [Input] Matrix line count                       -
     * col      [Input] Matrix column count                     -
     * - Return
     * void
     */
    matrix(int ln, int col)
    {
        if(ln && col) mat_ptr_init(ln, col);
        
    }
    /* - Overload
     * Array initialization construction function.
     * - Parameter
     * matrix_value [Input] Pointer matrix      -
     * line         [Input] Matrix line count   -
     * col          [Input] Matrix column count -
     * - Return
     * void
     */
    matrix(MATRIX &matrix_value, int line, int col)
    {
        if(line && col)
        {
            elem_st(line, col);
            this->matrix_value = copy_matrix(matrix_value, line, col);
        }
    }
    /* - Overload
     * String initialization construction function.
     * - Parameter
     * mat_char_form    [Input] String pointer matrix   -
     * - Return
     * void
     */
    matrix(std::string mat_char_form)
    {
        if (mat_char_form.length()) matrix_value = get_matrix(mat_char_form, line, column);
        else
        {
            std::cout << "Input the matrix for initialization: " << std::endl;
            matrix_value = get_matrix(paraInput(), line, column);
        }
    }
    /* - Overload
     * Copy construction function
     * - Parameter
     * mat_src  [Quote] Replication operation pointer matrix    -
     * - Return
     * void
     */
    matrix(const matrix &mat_src)
    {
        if (mat_src.elem_cnt)
        {
            mat_ptr_init(mat_src.line, mat_src.column);
            elem_st(mat_src.line, mat_src.column);
            if (column == mat_src.column && line == mat_src.line)
                for (auto i = 0; i < elem_cnt; i++)
                    matrix_value[i] = mat_src.matrix_value[i];
        }
    }
    matrix(const double atom_elem)
    {
        if(elem_cnt != 1)
        {
            if(elem_cnt > 1) destroy();
            mat_ptr_init(1, 1);
        }
        matrix_value[0] = atom_elem;
    }
    // Blank constructor.
    matrix() {}
    /* Random operation.
     * - Parameter
     * ln   [Input] Matrix line count   -
     * col  [Input] Matrix column count -
     * head [Input] First range         -1
     * rear [Input] Second range        1
     * err  [Input] Error               0.00005
     * -Return
     * This matrix
     */
    matrix rand_vec(uint64_t ln = 0, uint64_t col = 0, double head = 1, double rear = 1, double err = 1e-5)
    {
        std::default_random_engine e;
        if ((ln || col) && !elem_cnt) mat_ptr_init(ln, col);
        for (int i = 0; i < elem_cnt; i++)
            if(head==rear) matrix_value[i] = (((double)e() / (double)e._Max) - 0.5) * 2.0;
            else matrix_value[i] = random_number(head, rear, err);
        return *this;
    }
    /* Get matrix column count.
     * - Parameter
     * null
     * - Return
     * Matrix column count
     */
    int const get_column()
    {
        return column;
    }
    /* Get matrix line count.
     * - Parameter
     * null
     * - Return
     * Matrix line count
     */
    int const get_line()
    {
        return line;
    }
    /* Get determinant value.
     * - Parameter
     * null
     * - Return
     * Matrix's deteriant value
     */
    const double get_matrix_det_value()
    {
        if (line == column) return get_matrix_det(matrix_value, line);
        else return 0;
    }
    /* Adjudicate whether the matrix is zero matrix.
     * - Parameter
     * null
     * - Return
     * [true]   Zero matrix
     * [false]  Not zero matrix
     */
    bool is_O_matrix()
    {

        for (int i = 0; i < line; i++)
            for (int j = 0; j < column; j++)
                if (matrix_value[get_elem_pos(i, j, line, column)])
                    return false;
        return true;
    }
    /* Adjudicate whether the matrix is not null pointer.
     * - Parameter
     * null
     * - Return
     * [true]   Not null pointer
     * [false]  Null pointer
     */
    bool is_matrix()
    {
        if (elem_cnt) return true;
        else return false;
    }
    bool is_atom()
    {
        return (line==1 && column==1);
    }
    /* Matrix transposition calculation.
     * - Parameter
     * null
     * - Return
     * Transposition operation result
     */
    matrix transposition()
    {
        int buffer = line;
        line = column;
        column = buffer;
        auto tool_mat = copy_matrix(matrix_value, elem_cnt);
        delete_matrix(matrix_value);
        matrix_value = matrix_transposition(tool_mat, line, column, false);
        return *this;
    }
    /* - Overload
     * Matrix transposition calculation.
     * - Parameter
     * matrix_source    [Quote] Matrix  -
     * - Return
     * Transposition matrix
     */
    static matrix transposition(matrix &matrix_source)
    {
        return matrix(matrix_transposition(matrix_source.matrix_value, matrix_source.line, matrix_source.column), matrix_source.column, matrix_source.line);
    }
    /* Get matrix's max value.
     * - Parameter
     * ln   [Output]    Max value's line directed position in matrix    -
     * col  [Output]    Max value's column directed position in matrix  -
     * - Return
     * Max value
     */
    double max_value(int &ln, int &col)
    {
        auto pos = 0;
        for(auto i=0; i<elem_cnt; i++)
            if(matrix_value[i] > matrix_value[pos]) pos = i;
        auto pos_pair = get_elem_pos(pos, line, column);
        ln = pos_pair.first;
        col = pos_pair.second;
        return matrix_value[pos];
    }
    /* - Overload
     * Get matrix's max value.
     * - Parameter
     * mat_var  [Quote]     Matrix                                          -
     * ln       [Output]    Max value's line directed position in matrix    -
     * col      [Output]    Max value's column directed position in matrix  -
     * - Return
     * Max value
     */
    static double max_value(matrix &mat_var, int &ln, int &col)
    {
        return mat_var.max_value(ln, col);
    }
    /* Get matrix's min value.
     * - Parameter
     * ln   [Output]    Max value's line directed position in matrix    -
     * col  [Output]    Max value's column directed position in matrix  -
     * - Return
     * Min value
     */
    double min_value(int &ln, int &col)
    {
        auto pos = 0;
        for(auto i=0; i<elem_cnt; i++)
            if(matrix_value[i] < matrix_value[pos]) pos = i;
        auto pos_pair = get_elem_pos(pos, line, column);
        ln = pos_pair.first;
        col = pos_pair.second;
        return matrix_value[pos];
    }
    /* - Overload
     * Get matrix's min value.
     * - Parameter
     * mat_var  [Quote]     Matrix                                          -
     * ln       [Output]    Max value's line directed position in matrix    -
     * col      [Output]    Max value's column directed position in matrix  -
     * - Return
     * Min value
     */
    static double min_value(matrix &mat_var, int &ln, int &col)
    {
        return mat_var.min_value(ln, col);
    }
    double get_avg_value(uint64_t pos, bool is_col_vec = true)
    {
        double sum = 0;
        if(is_col_vec)
        {
            for(auto i=0; i<line; i++) sum += matrix_value[get_elem_pos(i, pos, line, column)];
            return sum / line;
        }
        else
        {
            for(auto i=0; i<column; i++) sum += matrix_value[get_elem_pos(pos, i, line, column)];
            return sum / column;
        }
    }
    double get_max_value(uint64_t pos, uint64_t &loc, bool is_col_vec = true)
    {
        loc = 0;
        if(is_col_vec)
        {
            for(auto i=0; i<line; i++)
                if(matrix_value[get_elem_pos(i, pos, line, column)] > matrix_value[get_elem_pos(loc, pos, line, column)])
                    loc = i;
            return matrix_value[get_elem_pos(loc, pos, line, column)];
        }
        else
        {
            for(auto i=0; i<column; i++)
                if(matrix_value[get_elem_pos(pos, i, line, column)] > matrix_value[get_elem_pos(pos, loc, line, column)])
                    loc = i;
            return matrix_value[get_elem_pos(pos, loc, line, column)];
        }
    }
    double get_min_value(uint64_t pos, uint64_t &loc, bool is_col_vec = true)
    {
        loc = 0;
        if(is_col_vec)
        {
            for(auto i=0; i<line; i++)
                if(matrix_value[get_elem_pos(i, pos, line, column)] < matrix_value[get_elem_pos(loc, pos, line, column)])
                    loc = i;
            return matrix_value[get_elem_pos(loc, pos, line, column)];
        }
        else
        {
            for(auto i=0; i<column; i++)
                if(matrix_value[get_elem_pos(pos, i, line, column)] < matrix_value[get_elem_pos(pos, loc, line, column)])
                    loc = i;
            return matrix_value[get_elem_pos(pos, loc, line, column)];
        }
    }
    /* Get column vector pointer.
     * - Parameter
     * null
     * - Return
     * Column matrix pointer
     */
    MATRIX get_vector_ptr()
    {
        return copy_matrix(matrix_value, line, column);
    }
    MATRIX get_vector_ptr(uint64_t col)
    {
        auto vec = std::make_unique<double[]>(line);
        for(auto i=0; i<line; i++) vec[i] = matrix_value[get_elem_pos(i, col, line, column)];
        return vec;
    }
    /* Get single dimension vector series.
     * - Parameter
     * null
     * - Return
     * Line matrix pointer
     */
    MATRIX get_series_ptr()
    {
        return get_vector_ptr();
    }
    MATRIX get_series_ptr(uint64_t ln)
    {
        auto vec = std::make_unique<double[]>(line);
        for(auto i=0; i<column; i++) vec[i] = matrix_value[get_elem_pos(ln, i, line, column)];
        return vec;
    }
    /* Get Atomic matrix's value.
     * - Parameter
     * null
     * - Return
     * Atomic value
     */
    double get_atom_vec()
    {
        return matrix_value[0];
    }
    /* Get matrix's child vector.
     * - Parameter
     * from_ln  [Input] Child matrix top position of parent matrix      -
     * to_ln    [Input] Child matrix bottom position of parent matrix   -
     * from_col [Input] Child matrix left position of parent matrix     -
     * to_col   [Input] Child matrix right position of parent matrix    -
     * - Return
     * Current matrix's sub matrix
     */
    matrix get_child_vec(int from_ln, int to_ln, int from_col, int to_col)
    {
        matrix mat_child;
        if (from_ln <= to_ln && from_col <= to_col && to_ln < line && to_col < column)
        {
            mat_child = matrix(to_ln - from_ln + 1, to_col - from_col + 1);
            auto nLnCnt = 0;
            for (auto i = from_ln; i <= to_ln; i++)
            {
                auto nColCnt = 0;
                for (auto j = from_col; j <= to_col; j++)
                    mat_child.matrix_value[get_elem_pos(nLnCnt, nColCnt++, mat_child.line, mat_child.column)] = matrix_value[get_elem_pos(i, j, line, column)];
                nLnCnt++;
            }
        }
        return mat_child;
    }
    /* Get matrix single column vector.
     * - Parameter
     * col  [Input] Vector's column loaction    -
     * - Return
     * Counterpart column of matrix's column vector
     */
    matrix get_vector(int col)
    {
        return get_child_vec(0, line-1, col, col);
    }
    matrix get_series(uint64_t ln)
    {
        return get_child_vec(ln, ln, 0, column-1);
    }
    /* Rotate π/2 radian for all element of matrix.
     * - Parameter
     * null
     * - Return
     * Rotate result
     */
    matrix rotate_rect()
    {
        auto rot_matrix = copy_matrix(matrix_value, elem_cnt);
        matrix_value.reset();
        matrix_value = rotate_rect_matrix(rot_matrix, line, column);
        return *this;
    }
    /* - Overload
     * Rotate π/2 radian for all element of matrix.
     * - Parameter
     * mat_var  [Quote] Matrix source   -
     * - Return
     * Rotated matrix
     */
    static matrix rotate_rect(matrix &mat_var)
    {
        auto mat_rot = mat_var;
        return mat_rot.rotate_rect();
    }
    /* Reshape the matrix.
     * - Parameter
     * ln   [Input] Shape line count    -
     * col  [Input] Shape column count  -
     * - Return
     * Reshape result
     */
    matrix reshape(uint64_t ln, uint64_t col)
    {
        if (ln * col == line * column)
        {
            line = ln;
            column = col;
            return *this;
        }
        else throw std::logic_error("Reshape failed!\n");
    }
    /* - Overload
     * Reshape the matrix.
     * - Parameter
     * vec  [Quote] Matrix source       -
     * ln   [Input] Shape line count    -
     * col  [Input] Shape column count  -
     * - Return
     * Reshaped matrix
     */
    static matrix reshape(matrix &vec, uint64_t ln, uint64_t col)
    {
        auto shape_mat = vec;
        return shape_mat.reshape(ln, col);
    }
    /* - Overload
     * Reshape the matrix.
     * - Parameter
     * vec_like     [Quote] Shape matrix    -
     * cpy_value    [Input] Copy value flag false
     * - Return
     * void
     */
    void reshape(const matrix &vec_like, bool cpy_value = false)
    {
        delete_matrix(matrix_value);
        mat_ptr_init(vec_like.line, vec_like.column);
        if (cpy_value)
            for (auto i = 0; i < elem_cnt; i++)
                matrix_value[i] = vec_like.matrix_value[i];
        
    }
    /* - Overload
     * Reshape the matrix.
     * - Parameter
     * vec_opt      [Quote] Operation matrix    -
     * vec_like     [Quote] Shape matrix        -
     * cpy_value    [Input] Copy value flag false
     * - Return
     * Operated matrix
     */
    static matrix reshape(const matrix &vec_opt, const matrix &vec_like, bool cpy_value = false)
    {
        auto vec_res = vec_opt;
        vec_res.reshape(vec_like, cpy_value);
        return vec_res;
    }
    /* check two matrix if there shape are same.
     * - Parameter
     * vec_src  [Quote] Authentic matrix    -
     * - Return
     * [true]   same shape
     * [false]  different shape
     */
    bool shape_examin(const matrix& vec_src){
        return ((column==vec_src.column) && (line==vec_src.line));
    }
    /* All elements addition.
     * - Parameter
     * null
     * - Return
     * Elements sum value
     */
    double sum_elem()
    {
        auto elem_cnt = line * column;
        double sum = 0;
        for (auto i = 0; i < elem_cnt; i++)
            sum += matrix_value[i];
        return sum;
    }
    /* All elements average value.
     * - Parameter
     * null
     * - Return
     * Elements averagevalue
     */
    double avg_elem()
    {
        auto sum = sum_elem();
        auto elem_cnt = line * column;
        return sum / elem_cnt;
    }
    /* Absolute calculation
     * - Parameter
     * null
     * - Return
     * void
     */
    void abs_opt()
    {
        for(auto i=0; i<elem_cnt; i++) matrix_value[i] = absolute_value(matrix_value[i]);
    }
    static matrix abs_opt(matrix &vec_src)
    {
        auto opt_vec = vec_src;
        opt_vec.abs_opt();
        return opt_vec;
    }
    /* Travel iteration
     * - Parameter
     * func_ptr [Input] Traveling function pointer  -
     * - Return
     * void
     */
    void travel(double (*func_ptr)(double &))
    {
        auto elem_cnt = line * column;
        for (auto i = 0; i < elem_cnt; i++)
            matrix_value[i] = func_ptr(matrix_value[i]);
    }
    /* - Overload
     * - Parameter
     * func_ptr [Input] Traveling function pointer  -
     * - Return
     * void
     */
    void travel(double (*func_ptr)(double))
    {
        for (auto i = 0; i < elem_cnt; i++)
            matrix_value[i] = func_ptr(matrix_value[i]);
    }
    /* - Overload
     * Travel iteration
     * - Parameter
     * vec_src  [Quote] Matrix source
     * func_ptr [Input] Traveling function pointer  -
     * - Return
     * Operated matrix
     */
    static matrix travel(matrix &vec_src, double (*func_ptr)(double &))
    {
        auto cpy_vec = vec_src;
        cpy_vec.travel(func_ptr);
        return cpy_vec;
    }
    /* Element division
     * - Parameter
     * divisor  [Input] Divisor -
     * - Return 
     * void
     */
    matrix elem_division(double divisor)
    {
        for(auto i=0; i<elem_cnt; i++) matrix_value[i] /= divisor;
        return *this;
    }
    /* - Overload
     * Element division
     * - Parameter
     * org_vec  [Quote] Matrix source   - 
     * divisor  [Input] Divisor         -
     * - Return 
     * Operated matrix
     */
    static matrix elem_division(matrix &org_vec, double divisor)
    {
        matrix vec_opt;
        if(org_vec.is_matrix())
        {
            vec_opt = org_vec;
            vec_opt.elem_division(divisor);
        }
        return vec_opt;
    }
    /* - Overload
     * 
     * - Parameter
     * 
     * - Return
     *
     */
    matrix elem_division(matrix &divr_mat)
    {
        if(column==divr_mat.column && line==divr_mat.line)
            for(auto i=0; i<elem_cnt; i++)
                matrix_value[i] /= divr_mat.matrix_value[i];
        return *this;
    }
    static matrix elem_division(matrix &divd_mat, matrix &divr_mat)
    {
        if(divd_mat.line==divr_mat.line && divd_mat.column==divr_mat.column)
        {
            matrix mat_opt(divd_mat.line, divd_mat.column);
            for(auto i=0; i<mat_opt.elem_cnt; i++)
                mat_opt.matrix_value[i] = divd_mat.matrix_value[i] / divr_mat.matrix_value[i];
            return mat_opt;
        }
        else return matrix();
    }
    // Dot multiplication
    matrix elem_mult(matrix &mat_coe)
    {
        if(mat_coe.line==line && mat_coe.column==column)
            for(auto i=0; i<elem_cnt; i++)
                matrix_value[i] *= mat_coe.matrix_value[i];
        return *this;
    }
    static matrix elem_mult(matrix &l_mat, matrix &r_mat)
    {
        if(l_mat.line==r_mat.line && l_mat.column==r_mat.column)
        {
            matrix opt_res(l_mat.line, l_mat.column);
            for(auto i=0; i<opt_res.elem_cnt; i++)
                opt_res.matrix_value[i] = l_mat.matrix_value[i] * r_mat.matrix_value[i];
            return opt_res;
        }
        else return matrix();
    }
    matrix elem_power(double expon)
    {
        for(auto i=0; i<elem_cnt; i++) matrix_value[i] = pow(matrix_value[i], expon);
        return *this;
    }
    static matrix elem_power(matrix &vec, double expon)
    {
        MATRIX root_vec = copy_matrix(vec.matrix_value, vec.elem_cnt);
        for(auto i=0; i<vec.elem_cnt; i++) root_vec[i] = pow(root_vec[i], expon);
        return matrix(root_vec, vec.line, vec.column);
    }
    void padding(uint64_t ln_cnt, uint64_t col_cnt, uint64_t ln_dist = 0, uint64_t col_dist = 0)
    {
        auto m_ln = 2 * ln_cnt + line + (line - 1) * ln_dist,
            m_col = 2 * col_cnt + column + (column - 1) * col_dist;
        auto m_elem_cnt = m_ln * m_col;
        auto ptr_vec = copy_matrix(matrix_value, elem_cnt);
        delete_matrix(matrix_value);
        matrix_value = init_matrix(m_elem_cnt);
        for(auto i=0; i<line; i++)
            for(auto j=0; j<column; j++)
                matrix_value[get_elem_pos(ln_cnt+i*(ln_dist+1), col_cnt+j*(col_dist+1), m_ln, m_col)] = ptr_vec[get_elem_pos(i, j, line, column)];
        delete_matrix(ptr_vec);
        elem_cnt = m_elem_cnt;
        line = m_ln;
        column = m_col;
    }
    static matrix padding(matrix &src, uint64_t ln_cnt, uint64_t col_cnt, uint64_t ln_dist = 0, uint64_t col_dist = 0)
    {
        auto vec_opt = src;
        vec_opt.padding(ln_cnt, col_cnt, ln_dist, col_dist);
        return vec_opt;
    }
    void crop(uint64_t t_cnt, uint64_t r_cnt, uint64_t b_cnt, uint64_t l_cnt)
    {
        auto ln = line - t_cnt - b_cnt,
            col = column - l_cnt - r_cnt;
        auto elem_sum = ln * col;
        auto nov_mat = init_matrix(elem_sum);
        for(auto i=0; i<ln; i++)
            for(auto j=0; j<col; j++) nov_mat[get_elem_pos(i, j, ln, col)] = matrix_value[get_elem_pos(i+t_cnt, j+l_cnt, line, column)];
        delete_matrix(matrix_value);
        elem_st(ln, col);
        matrix_value = copy_matrix(nov_mat, elem_sum);
        delete_matrix(nov_mat);
    }
    static matrix crop(matrix &src, uint64_t t_cnt, uint64_t r_cnt, uint64_t b_cnt, uint64_t l_cnt)
    {
        auto vec_opt = src;
        vec_opt.crop(t_cnt, r_cnt, b_cnt, l_cnt);
        return vec_opt;
    }
    // Operator Overload
    // Access
    double *operator[](int line_num)
    {
        return matrix_value.get() + line_num * column;
    }
    // Addition
    matrix operator+(matrix &right_matrix)
    {
        if (line == right_matrix.get_line() && column == right_matrix.get_column())
            return matrix(add_matrix(matrix_value, right_matrix.matrix_value, line, column), line, column);
        else return *this;
    }
    matrix operator+(double add_val)
    {
        return matrix(add_value(matrix_value, add_val, elem_cnt), line, column);
    }
    // Additon
    void operator+=(matrix &mat)
    {
        auto l_mat = copy_matrix(matrix_value, elem_cnt);
        delete_matrix(matrix_value);
        matrix_value = add_matrix(l_mat, mat.matrix_value, line, column);
        delete_matrix(l_mat);
    }
    // Addition
    void operator+=(double add_val)
    {
        auto l_mat = copy_matrix(matrix_value, elem_cnt);
        delete_matrix(matrix_value);
        matrix_value = add_value(l_mat, add_val, elem_cnt);
        delete_matrix(l_mat);
    }
    // Subtraction
    matrix operator-(matrix &right_matrix)
    {
        if (line == right_matrix.get_line() && column == right_matrix.get_column())
            return matrix(subtract_matrix(matrix_value, right_matrix.matrix_value, line, column), line, column);
        else return *this;
    }
    // Subtraction
    matrix operator-(double sub_val)
    {
        return matrix(subtract_value(matrix_value, sub_val, elem_cnt), line, column);
    }
    // Subtraction
    void operator-=(matrix &mat)
    {
        auto l_mat = copy_matrix(matrix_value, elem_cnt);
        delete_matrix(matrix_value);
        matrix_value = subtract_matrix(l_mat, mat.matrix_value, line, column);
        delete_matrix(l_mat);
    }
    // Subtraction
    void operator-=(double sub_val)
    {
        auto l_mat = copy_matrix(matrix_value, elem_cnt);
        delete_matrix(matrix_value);
        matrix_value = subtract_value(l_mat, sub_val, elem_cnt);
        delete_matrix(l_mat);
    }
    // Multiplication
    matrix operator*(matrix &right_matrix)
    {
        if (column == right_matrix.get_line())
            return matrix(multiply_matrix(matrix_value, right_matrix.matrix_value, line, column, right_matrix.line, right_matrix.column), line, right_matrix.column);
        else return *this;
    }
    // Multiplication
    matrix operator*(double coefficiency)
    {
        matrix out_mat(matrix_value, line, column);
        for (int i = 0; i < out_mat.elem_cnt; i++)
            out_mat.matrix_value[i] *= coefficiency;
        return out_mat;
    }
    // Multiplication
    void operator*=(matrix &mat)
    {
        auto l_mat = copy_matrix(matrix_value, elem_cnt);
        delete_matrix(matrix_value);
        matrix_value = multiply_matrix(l_mat, mat.matrix_value, line, column, mat.line, mat.column);
        column = mat.column;
        delete_matrix(l_mat);
    }
    // Multiplication
    void operator*=(double coefficiency)
    {
        for (auto i = 0; i < elem_cnt; i++) matrix_value[i] *= coefficiency;
    }
    // Power
    matrix operator^(const int exponent)
    {
        auto expon = exponent;
        if (line == column && exponent !=1)
        {
            if (expon == -1) return matrix(get_inverse_matrix(matrix_value, line), line, column);
            if (expon == 0) return matrix(init_E_vec(line), line, line);
            if (expon > 1)
            {
                MATRIX vec = init_E_vec(line);
                for(auto i=0; i<expon; i++) vec = multiply_matrix(vec, matrix_value, line, column, line, column);
                return matrix(vec, line, column);
            }
        }
        if (exponent == 1) return matrix(matrix_value, line, column);
        else return matrix(line, column);
    }
    // Assignment
    matrix operator=(const matrix &mat)
    {
        if (*this != mat) if (line != mat.line || column != mat.column)
        {
            if (matrix_value) delete_matrix(matrix_value);
            mat_ptr_init(mat.line, mat.column);
        }
        for (auto i = 0; i < elem_cnt; i++) matrix_value[i] = mat.matrix_value[i];
        return *this;
    }
    // Logical adjudication
    bool operator==(const matrix &mat)
    {
        if (line == mat.line && column == mat.column)
        {
            auto elem_cnt = line * column;
            for (int i = 0; i < elem_cnt; i++)
                if (matrix_value[i] != mat.matrix_value[i])
                    return false;
            return true;
        }
        else return false;
    }
    // Logical adjudication
    bool operator!=(const matrix &mat)
    {
        return !(*this == mat);
    }
    // I/O Stream
    friend std::ostream &operator<<(std::ostream &output, const matrix &out_matrix)
    {
        for(auto i=0; i<out_matrix.elem_cnt; i++)
        {
            output << out_matrix.matrix_value[i];
            if(!((i+1)%out_matrix.column || (i+1)==out_matrix.elem_cnt)) output << std::endl;
            else output << '\t'; 
        }
        return output;
    }
    void destroy()
    {
        if(elem_cnt) delete_matrix(matrix_value);
        line = 0;
        column = 0;
        elem_cnt = 0;
    }
    /* Destruction function
     * - Parameter
     * null
     * - Return
     * void
     */
    ~matrix()
    {
        destroy();
    }
};

// MATRIX NAMESPACE_END
MATRIX_END